<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>사다리 게임 시뮬레이터 — 큰 수의 법칙 캠페인</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#60a5fa;--muted:#94a3b8;--danger:#fb7185}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans KR',sans-serif;background:linear-gradient(180deg,#071126 0%, #031024 100%);color:#e6eef8;margin:0;padding:28px;}
    .wrap{max-width:980px;margin:0 auto}
    header{display:flex;align-items:center;gap:18px}
    h1{margin:0;font-size:20px}
    p.lead{margin:6px 0 18px;color:var(--muted)}
    .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03);padding:16px;border-radius:12px;margin-bottom:16px}
    .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    label{font-size:13px;color:var(--muted)}
    input[type=number], select{padding:8px;border-radius:8px;background:#071022;border:1px solid rgba(255,255,255,0.04);color:#e6eef8}
    button{background:var(--accent);border:none;padding:10px 12px;border-radius:10px;color:#04233a;cursor:pointer;font-weight:600}
    button.secondary{background:#1f2937;color:#e6eef8}
    .board-wrap{display:flex;gap:18px;align-items:flex-start}
    .board{width:420px;height:420px;background:linear-gradient(180deg,#071526,#021023);border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
    svg{width:100%;height:100%}
    .stats{flex:1}
    .bar{height:28px;background:#0b1726;border-radius:8px;display:flex;align-items:center;padding:4px;margin-bottom:8px}
    .bar > .fill{height:100%;border-radius:6px;background:linear-gradient(90deg,var(--accent),#3b82f6);display:flex;align-items:center;padding-left:8px;color:#041022;font-weight:700}
    .small{font-size:13px;color:var(--muted)}
    footer{margin-top:14px;color:var(--muted);font-size:13px}
    .note{background:rgba(251,113,133,0.06);border-left:4px solid var(--danger);padding:10px;border-radius:8px;color:#ffdfe6}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>사다리 게임 시뮬레이터 — 큰 수의 법칙(Law of Large Numbers) 캠페인</h1>
        <p class="lead">컴퓨터공학과 진로를 가진 모둠을 위한 웹페이지. 사다리 게임을 무작위로 여러 번 돌려 결과 분포가 수렴하는 모습을 보여주어 도박의 위험성을 설명합니다.</p>
      </div>
    </header>

    <section class="panel">
      <div class="controls">
        <label>열 수 (플레이어 수):
          <input id="cols" type="number" min="2" max="12" value="5" />
        </label>
        <label>행 수 (사다리 단계):
          <input id="rows" type="number" min="3" max="30" value="12" />
        </label>
        <label>시뮬레이션 횟수:
          <input id="trials" type="number" min="1" max="1000000" value="2000" />
        </label>
        <button id="runSim">시뮬레이션 실행</button>
        <button id="single" class="secondary">한 번 실행</button>
        <button id="regen" class="secondary">사다리 새로 만들기</button>
        <div style="margin-left:auto;text-align:right">
          <div class="small">결과는 무작위성이지만, 표본 수를 키울수록 상대도수는 기대확률에 수렴합니다.</div>
        </div>
      </div>
    </section>

    <div class="board-wrap">
      <div class="board panel" id="boardPanel">
        <svg id="ladderSvg" viewBox="0 0 400 400" preserveAspectRatio="xMidYMid meet"></svg>
      </div>

      <div class="stats panel">
        <h3 style="margin-top:0">통계·결과</h3>
        <div id="bars"></div>
        <div style="margin-top:10px" class="small">시행 횟수: <span id="total">0</span></div>
        <div style="margin-top:10px" class="note">
          <strong>캠페인 메시지:</strong> 도박은 장기적으로 불리한 기대값과 높은 분산을 동반합니다. 큰 수의 법칙은 표본이 커질 때 상대도수가 어떤 값(기대값)에 가까워진다는 것을 의미합니다. 무작위 게임에서 단기간의 이득은 우연이지만, 반복하면 얻을 수 있는 평균은 예측 가능합니다 — 대부분의 경우 개인에게 불리합니다.
        </div>
      </div>
    </div>

    <footer class="panel">
      <div class="small">이 페이지는 교육용으로 제작되었습니다. 코드를 수정하여 디자인, 메시지, 보상 구조(결과 값)를 바꿀 수 있습니다.</div>
    </footer>
  </div>

  <script>
    // 사다리 생성과 시뮬레이션: 기본 사다리(열 cols, 행 rows)에서 좌우로 무작위 가로선을 배치
    // 플레이어는 위에서부터 내려오며 가로선이 있으면 좌우로 이동.

    const svg = document.getElementById('ladderSvg');
    const colsIn = document.getElementById('cols');
    const rowsIn = document.getElementById('rows');
    const trialsIn = document.getElementById('trials');
    const runSim = document.getElementById('runSim');
    const singleBtn = document.getElementById('single');
    const regen = document.getElementById('regen');
    const bars = document.getElementById('bars');
    const totalLabel = document.getElementById('total');

    let cols = parseInt(colsIn.value,10);
    let rows = parseInt(rowsIn.value,10);
    let ladder = []; // rows x (cols-1) -> whether a rung exists between i and i+1 at that row
    let counts = [];

    function randBool(p=0.35){return Math.random() < p}

    function makeLadder(){
      cols = Math.min(12, Math.max(2, parseInt(colsIn.value||5,10)));
      rows = Math.min(40, Math.max(3, parseInt(rowsIn.value||12,10)));
      ladder = Array.from({length:rows}, ()=>Array.from({length:cols-1}, ()=>false));
      // 랜덤 가로선 배치: 같은 row에서 인접 두 가로선은 허용하지 않음 (교차 금지)
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols-1;c++){
          if(c>0 && ladder[r][c-1]){ // 바로 왼쪽에 가로선이 있으면 건너뛴다
            ladder[r][c]=false; continue;
          }
          ladder[r][c]=randBool(0.35);
        }
      }
      counts = Array.from({length:cols}, ()=>0);
      render();
    }

    function render(highlightPaths){
      // draw ladder in svg
      svg.innerHTML='';
      const W=400, H=400, left=40, right=W-40, top=20, bottom=H-20;
      const gapX = (right-left)/(cols-1);
      const gapY = (bottom-top)/(rows-1);

      // vertical lines
      for(let c=0;c<cols;c++){
        const x=left + c*gapX;
        const line = document.createElementNS('http://www.w3.org/2000/svg','line');
        line.setAttribute('x1',x); line.setAttribute('y1',top); line.setAttribute('x2',x); line.setAttribute('y2',bottom);
        line.setAttribute('stroke','#2e4a66'); line.setAttribute('stroke-width','2');
        svg.appendChild(line);
      }
      // horizontal rungs
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols-1;c++){
          if(ladder[r][c]){
            const x1 = left + c*gapX;
            const x2 = left + (c+1)*gapX;
            const y = top + r*gapY;
            const h = document.createElementNS('http://www.w3.org/2000/svg','line');
            h.setAttribute('x1',x1); h.setAttribute('x2',x2); h.setAttribute('y1',y); h.setAttribute('y2',y);
            h.setAttribute('stroke','#6fb0ff'); h.setAttribute('stroke-width','3');
            svg.appendChild(h);
          }
        }
      }

      // labels at top and bottom
      for(let c=0;c<cols;c++){
        const x=left + c*gapX;
        const t1 = document.createElementNS('http://www.w3.org/2000/svg','text');
        t1.setAttribute('x',x); t1.setAttribute('y',top-8);
        t1.setAttribute('text-anchor','middle'); t1.setAttribute('font-size','12'); t1.setAttribute('fill','#cfe8ff');
        t1.textContent = String(c+1);
        svg.appendChild(t1);

        const t2 = document.createElementNS('http://www.w3.org/2000/svg','text');
        t2.setAttribute('x',x); t2.setAttribute('y',bottom+16);
        t2.setAttribute('text-anchor','middle'); t2.setAttribute('font-size','12'); t2.setAttribute('fill','#cfe8ff');
        t2.textContent = String(c+1);
        svg.appendChild(t2);
      }

      // if highlightPaths: draw small circles tracing sample paths
      if(Array.isArray(highlightPaths)){
        highlightPaths.forEach((pos,i)=>{
          const colx = left + pos*gapX;
          const y = bottom + 28 + (i*6);
          const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
          circ.setAttribute('cx',colx); circ.setAttribute('cy',y); circ.setAttribute('r',3);
          circ.setAttribute('fill','#ffd166');
          svg.appendChild(circ);
        });
      }
    }

    function runOne(startCol){
      // startCol is index 0..cols-1
      let pos = startCol;
      for(let r=0;r<rows;r++){
        if(pos>0 && ladder[r][pos-1]){ pos = pos-1; continue; }
        if(pos<cols-1 && ladder[r][pos]){ pos = pos+1; continue; }
        // else stay
      }
      return pos;
    }

    function updateBars(){
      bars.innerHTML='';
      const total = counts.reduce((a,b)=>a+b,0);
      totalLabel.textContent = total;
      for(let i=0;i<cols;i++){
        const perc = total>0? (counts[i]/total*100):0;
        const bar = document.createElement('div'); bar.className='bar';
        const fill = document.createElement('div'); fill.className='fill';
        fill.style.width = Math.max(6,perc)+'%';
        fill.textContent = `${i+1} : ${counts[i]} (${perc.toFixed(2)}%)`;
        bar.appendChild(fill);
        bars.appendChild(bar);
      }
    }

    function simulate(n){
      const start = Date.now();
      for(let t=0;t<n;t++){
        const s = Math.floor(Math.random()*cols);
        const end = runOne(s);
        counts[end]++;
      }
      updateBars();
      console.log('sim done in',Date.now()-start,'ms');
    }

    // Hook up UI
    runSim.addEventListener('click', ()=>{
      const n = Math.min(1000000, Math.max(1, parseInt(trialsIn.value||1000,10)));
      simulate(n);
    });

    singleBtn.addEventListener('click', ()=>{
      // run one game for each starting column once and visualize end positions
      const paths = [];
      for(let s=0;s<cols;s++){
        const end = runOne(s);
        counts[end]++;
        paths.push(end);
      }
      render(paths);
      updateBars();
    });

    regen.addEventListener('click', ()=>{ makeLadder(); });

    colsIn.addEventListener('change', ()=>{ makeLadder(); });
    rowsIn.addEventListener('change', ()=>{ makeLadder(); });

    // 초기화
    makeLadder();

    // 교육용: 사용자가 표본수를 올리면 큰 수의 법칙을 직접 확인할 수 있음.
    // 예: trials=2000 이상으로 늘리면 분포의 안정화(수렴) 경향을 관찰할 수 있음.

  </script>
</body>
</html>
