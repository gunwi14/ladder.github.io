<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>í™€ì§ ë„ë°• ì‹œë®¬ë ˆì´ì…˜ â€” ì‚¬ìš´ë“œ ì•ˆì •í™” ë²„ì „</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background: linear-gradient(135deg,#2b5876,#4e4376);
    color: white;
    text-align: center;
    padding-top: 36px;
    overflow: hidden;
  }
  .card {
    width: 380px;
    margin: 20px auto;
    background: rgba(255,255,255,0.06);
    border-radius: 12px;
    padding: 22px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.25);
  }
  h1 { margin: 0 0 8px 0; font-size: 22px; }
  #balance,#goal { margin: 6px 0; font-size: 18px; color: #ffd166; }
  .controls { margin-top: 12px; }
  input[type="number"]{
    width:160px;padding:8px;border-radius:6px;border:none;text-align:right;font-size:16px;
  }
  button {
    padding:10px 18px;margin:10px;border-radius:8px;border:none;background:#ffb703;color:#112;
    font-weight:700;cursor:pointer;font-size:16px;
  }
  button:hover{transform:translateY(-3px);transition:all .12s}
  #result { margin-top:12px; font-size:16px; min-height:36px; }
  /* í”Œë¡œíŒ… í…ìŠ¤íŠ¸ */
  .floating-text { position:absolute; font-size:22px; font-weight:800; pointer-events:none; animation:floatUp 1.2s ease-out forwards; text-shadow:0 2px 8px rgba(0,0,0,0.6);}
  @keyframes floatUp { 0%{opacity:1; transform:translateY(0) scale(1)} 100%{opacity:0; transform:translateY(-120px) scale(1.05)} }
  /* í™”ë©´ í”Œë˜ì‹œ (ë§¤ ë°°íŒ…ë§ˆë‹¤) */
  .flash { animation: screenFlash .18s ease; }
  @keyframes screenFlash { 0%{filter:brightness(1.6)} 100%{filter:brightness(1)} }
  .smallnote{font-size:12px;color:#dbeafe;margin-top:6px}
</style>
</head>
<body>
  <div class="card" id="panel">
    <h1>ğŸ² í™€ì§ ë„ë°• ì‹œë®¬ë ˆì´ì…˜</h1>
    <div id="balance">ğŸ’° ë³´ìœ  ê¸ˆì•¡: 500,000ì›</div>
    <div id="goal">ğŸ¯ ëª©í‘œ ê¸ˆì•¡: 5,000,000ì›</div>

    <div class="controls">
      <div>
        ë² íŒ… ê¸ˆì•¡: <input id="bet" type="number" min="1000" value="10000" step="1000"> ì›
      </div>
      <div style="margin-top:10px">
        <button id="btnOdd">í™€</button>
        <button id="btnEven">ì§</button>
      </div>
      <div id="result" aria-live="polite"></div>
      <div class="smallnote">â€» ìµœì†Œ ë² íŒ…ê¸ˆì•¡ 1,000ì› / ì„±ê³µ: +2ë°°, ì‹¤íŒ¨: -1.5ë°° (ìë™ ì´ˆê¸°í™”: íŒŒì‚° ë˜ëŠ” ëª©í‘œ ë‹¬ì„±)</div>
    </div>
  </div>

  <!-- ì™¸ë¶€ ìŒì› ì‹œë„ìš© (CORS/ì •ì±… ë¬¸ì œ ìˆì„ ìˆ˜ ìˆìŒ) -->
  <audio id="audioBet" crossorigin="anonymous"></audio>
  <audio id="audioWin" crossorigin="anonymous"></audio>
  <audio id="audioLose" crossorigin="anonymous"></audio>

<script>
/*
  ì•ˆì •ì  ì†Œë¦¬ ì¬ìƒ ë¡œì§:
  1) í˜ì´ì§€ ë¡œë“œì‹œ ì˜¤ë””ì˜¤ src ì„¸íŒ…(ì™¸ë¶€ URL). (playëŠ” ì‚¬ìš©ì ì•¡ì…˜ ë•Œ ìˆ˜í–‰)
  2) playSound(name) í˜¸ì¶œí•˜ë©´ í•´ë‹¹ <audio>ë¡œ play(). 
     - play()ê°€ ì„±ê³µí•˜ë©´ ì •ìƒ ì¬ìƒ.
     - play()ê°€ ê±°ë¶€(rejected)ë˜ê±°ë‚˜ ì—ëŸ¬ë‚˜ë©´, WebAudio APIë¡œ ì¦‰ì‹œ í•©ì„±ìŒ ì¬ìƒ(í´ë°±).
  3) ë²„íŠ¼ í´ë¦­(ì‚¬ìš©ì ì•¡ì…˜)ì—ì„œ ë°˜ë“œì‹œ playSound('bet') ë¨¼ì € í˜¸ì¶œ -> ì´í›„ ê²Œì„ ë¡œì§ ì‹¤í–‰.
*/

const audioFiles = {
  bet: 'https://assets.mixkit.co/sfx/preview/mixkit-game-click-1114.mp3',       // í´ë¦­
  win: 'https://assets.mixkit.co/sfx/preview/mixkit-winning-chime-2015.mp3',    // ìŠ¹ë¦¬ ì§œì”
  lose:'https://assets.mixkit.co/sfx/preview/mixkit-player-losing-or-failing-2042.mp3' // ì‹¤íŒ¨ ë­‰íˆ­
};

// Attach sources to audio elements (preload attempt)
const aBet = document.getElementById('audioBet');
const aWin = document.getElementById('audioWin');
const aLose = document.getElementById('audioLose');
aBet.src = audioFiles.bet;
aWin.src = audioFiles.win;
aLose.src = audioFiles.lose;
aBet.preload = 'auto'; aWin.preload='auto'; aLose.preload='auto';

// Web Audio fallback synth
let audioCtx = null;
function ensureAudioContext(){
  if(!audioCtx){
    try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
    catch(e){ audioCtx = null; }
  }
  return audioCtx;
}
function synthTone({freq=440, duration=0.18, type='sine', gain=0.12}){
  const ctx = ensureAudioContext();
  if(!ctx) return;
  const o = ctx.createOscillator();
  const g = ctx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.value = gain;
  o.connect(g); g.connect(ctx.destination);
  const now = ctx.currentTime;
  o.start(now);
  g.gain.setValueAtTime(gain, now);
  g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
  o.stop(now + duration + 0.02);
}

// playSound tries DOM Audio first, if fails use synth
async function playSound(kind){
  let el = null;
  if(kind === 'bet') el = aBet;
  if(kind === 'win') el = aWin;
  if(kind === 'lose') el = aLose;

  if(el){
    try{
      // ensure load attempt
      // using play() returns a promise â€” handle reject
      el.currentTime = 0;
      const p = el.play();
      if(p !== undefined){
        await p; // if this rejects we'll fall to catch
        return;
      } else {
        // Some browsers return undefined; assume played
        return;
      }
    } catch(err){
      // fallback to synth
      // console.warn('Audio element failed, using synth fallback', err);
    }
  }
  // Fallback synth patterns per kind
  if(kind === 'bet'){
    synthTone({freq:880,duration:0.06,gain:0.06,type:'square'});
  } else if(kind === 'win'){
    synthTone({freq:880,duration:0.18,gain:0.12,type:'sine'});
    setTimeout(()=>synthTone({freq:1320,duration:0.12,gain:0.09,type:'sine'}),90);
  } else if(kind === 'lose'){
    synthTone({freq:160,duration:0.20,gain:0.18,type:'sawtooth'});
    setTimeout(()=>synthTone({freq:120,duration:0.18,gain:0.12,type:'sawtooth'}),90);
  }
}

/* ---------------- game logic ---------------- */
let balance = 500000;
let failCount = 0;
let winRate = 0.35;

const balanceEl = document.getElementById('balance');
const goalEl = document.getElementById('goal');
const resultEl = document.getElementById('result');
const panel = document.getElementById('panel');
const btnOdd = document.getElementById('btnOdd');
const btnEven = document.getElementById('btnEven');
const betInput = document.getElementById('bet');

function updateDisplays(){
  balanceEl.textContent = `ğŸ’° ë³´ìœ  ê¸ˆì•¡: ${balance.toLocaleString()}ì›`;
  goalEl.textContent = `ğŸ¯ ëª©í‘œ ê¸ˆì•¡: 5,000,000ì›`;
}

// show floating text anywhere (called every bet)
function showFloatingText(text, color){
  const span = document.createElement('div');
  span.className = 'floating-text';
  span.style.color = color;
  span.innerText = text;
  // pick position within viewport (avoid edges)
  const padding = 40;
  const left = Math.floor(Math.random()*(window.innerWidth - padding*2)) + padding;
  const top  = Math.floor(Math.random()*(window.innerHeight - padding*2)) + padding;
  span.style.left = left + 'px';
  span.style.top = top + 'px';
  document.body.appendChild(span);
  setTimeout(()=> span.remove(), 1200);
}

function resetGame(){
  balance = 500000;
  failCount = 0;
  winRate = 0.35;
  betInput.value = 10000;
  updateDisplays();
  resultEl.innerHTML = '';
}

// main play (called after user clicked button)
async function doPlay(choice){
  const bet = Number(betInput.value);
  if(isNaN(bet) || bet < 1000){
    alert('ìµœì†Œ ë² íŒ… ê¸ˆì•¡ì€ 1,000ì›ì…ë‹ˆë‹¤.');
    return;
  }
  if(bet > balance && balance <= 0){
    alert('ì”ì•¡ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.');
    return;
  }

  // play bet sound & UI flash (user gesture)
  playSound('bet');
  panel.classList.add('flash');
  setTimeout(()=> panel.classList.remove('flash'), 180);

  // Always show floating text for bet attempt (neutral small)
  showFloatingText(`ë² íŒ… ${bet.toLocaleString()}ì›`, '#fff');

  // compute outcome using winRate
  const r = Math.random();
  const outcome = (r < winRate) ? choice : (choice === 'í™€' ? 'ì§' : 'í™€');
  const isWin = (outcome === choice);

  if(isWin){
    const gain = Math.floor(bet * 2); // success: +2ë°°
    balance += gain;
    failCount = 0;
    // play win sound
    await playSound('win');
    resultEl.innerHTML = `âœ… ìŠ¹ë¦¬! +${gain.toLocaleString()}ì› íšë“`;
    showFloatingText(`+${gain.toLocaleString()}`, '#9cff9c');
    // slightly decrease winRate to keep base lower, min 25%
    winRate = Math.max(0.25, (winRate - 0.02));
  } else {
    const loss = Math.floor(bet * 1.5); // failure: -1.5ë°°
    balance -= loss;
    failCount++;
    await playSound('lose');
    resultEl.innerHTML = `âŒ íŒ¨ë°°... -${loss.toLocaleString()}ì› ì†ì‹¤`;
    showFloatingText(`-${loss.toLocaleString()}`, '#ff9c9c');
    if(failCount >= 5){
      winRate = Math.min(0.5, winRate + 0.10);
      failCount = 0;
    }
  }

  updateDisplays();

  // Auto reset on bankruptcy or reaching goal
  if(balance <= 0){
    setTimeout(()=> {
      alert('ğŸ’€ íŒŒì‚°í•˜ì…¨ìŠµë‹ˆë‹¤. ê²Œì„ì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.');
      resetGame();
    }, 80);
  } else if(balance >= 5000000){
    setTimeout(()=> {
      alert('ğŸ‰ ëª©í‘œ ë‹¬ì„±! ê²Œì„ì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.');
      resetGame();
    }, 80);
  }
}

/* Attach click handlers â€” guarantee user gesture before audio playback attempts */
btnOdd.addEventListener('click', () => doPlay('í™€'));
btnEven.addEventListener('click', () => doPlay('ì§'));

/* initialize display */
updateDisplays();

/* Optional: try to unlock WebAudio on first user gesture (some mobile browsers require gesture) */
function unlockAudioOnFirstGesture(){
  const handler = async () => {
    // try a tiny synth to unlock
    const ctx = ensureAudioContext();
    if(ctx && ctx.state === 'suspended'){
      try { await ctx.resume(); } catch(e) {}
    }
    // try to play a silent short buffer on audio elements to warm them
    [aBet,aWin,aLose].forEach(el=>{
      try{ el.play().then(()=>el.pause()).catch(()=>{}); }catch(e){}
    });
    window.removeEventListener('pointerdown', handler);
  };
  window.addEventListener('pointerdown', handler, {once:true});
}
unlockAudioOnFirstGesture();

</script>
</body>
</html>
